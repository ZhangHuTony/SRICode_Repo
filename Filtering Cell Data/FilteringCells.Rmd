---
title: "FilteringCells"
author: "Tony Zhang"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(ggplot2)
library(RColorBrewer)
library(dplyr)

```

```{r}
Filt6_BarbieMelanoma_Dataframe = read.csv("Data/barbie6hrs.csv")
Filt6_KenMelanoma_Dataframe = read.csv("Data/ken6hrs.csv")
```

# Looking at individual cells

```{r}
singleCell_dataFrame = subset(Filt6_BarbieMelanoma_Dataframe, Tracking.ID == 2382)
```

```{r}
# Create the ggplot object with a darker background
p <- ggplot(singleCell_dataFrame, aes(x = Position.X, y = Position.Y, color = Frame)) +
  geom_point() +
  scale_color_gradientn(colours = terrain.colors(20)) +
  theme(panel.background = element_rect(fill = "black"))  # Remove panel border

# Print the plot
print(p)

```

```{r}
# Assuming 'singleCell_dataFrame' contains your data
# 'Frame' is the variable indicating the frame

# Define colors for the gradient
start_color <- "red"
end_color <- "blue"

# Create a color gradient based on the 'Frame' variable
color_gradient <- colorRampPalette(c(start_color, end_color))(nrow(singleCell_dataFrame))


# Plot the points without plotting lines initially
plot(singleCell_dataFrame$Position.X, singleCell_dataFrame$Position.Y, type = "n", xlab = "Position X", ylab = "Position Y")

# Draw lines between consecutive points with the same 'Frame' value
for (i in 2:nrow(singleCell_dataFrame)) {
  if (singleCell_dataFrame$Frame[i] - singleCell_dataFrame$Frame[i - 1] == 1) {
    lines(x = c(singleCell_dataFrame$Position.X[i - 1], singleCell_dataFrame$Position.X[i]), 
          y = c(singleCell_dataFrame$Position.Y[i - 1], singleCell_dataFrame$Position.Y[i]), 
          col = color_gradient[i])
  }
}

# Add points on top to ensure they are visible
points(singleCell_dataFrame$Position.X, singleCell_dataFrame$Position.Y, col = color_gradient)

```

# Filtering Based off Position

```{r}

# Haven't tested yet


## Function which completely removes all row occurences of a tracking ID whos final position was less than some distance from the edge. The edge is 1000 and 0 in both directions.
filter_DistanceFromEdge <- function(df, distance){

  filtered_df <- df %>%
    group_by(Tracking.ID) %>%
    filter((1000 - last(Position.X)) > distance & last(Position.X) > distance & (1000 - last(Position.Y)) > distance & last(Position.Y) > distance) %>%
  ungroup()
  result <- filtered_df
}
  
```

## Aggregating Data

```{r}
#Function which aggregates data using the Tracking ID as the shared key.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
aggregate_TrackingID <- function(nonAggDf){
  agg_df <- nonAggDf %>%
  group_by(Tracking.ID) %>%
  summarise(
    #Time between frame is 15 minutes
    Duration.minutes = (max(Frame) - min(Frame))*15,
    Duration.hours = Duration.minutes/60
  )
}


#Function which aggregates data using the Tracking ID as the shared key and creates a new column `maybeLeft` where if the final position was within some distance from the edge will be true.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
aggregate_TrackingID_EndPos <- function(nonAggDf, distance){

  agg_df <- nonAggDf %>%
    group_by(Tracking.ID) %>%
    summarise(
      #Time between frame is 15 minutes
      Duration.minutes = (max(Frame) - min(Frame))*15,
      Duration.hours = Duration.minutes/60,
      Position.FinalX = last(Position.X),
      Position.FinalY = last(Position.Y),
    #If distance from edge is more than `distance` it probably didn't leave

            maybeLeft = ifelse((1000 - Position.FinalX) > distance & Position.FinalX > distance & (1000 - Position.FinalY) > distance & last(Position.FinalY) > distance, FALSE, TRUE)

      )

}
```

```{r}
agg_Filt6_BarMel_Df = aggregate_TrackingID_EndPos(Filt6_BarbieMelanoma_Dataframe, 100)
head(agg_Filt6_BarMel_Df,20)


```

# Looking at filtered data

```{r}
#Function which takes two dataframes and the desired variable name to graph an empirical cdf of them.
#Call Example: "plot2Ecdf(barbieData, kenData, "Mean.Intensity")
plot2Ecdf <- function(bardf2, kendf1, variable){
  ggplot() +
    stat_ecdf(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    stat_ecdf(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    theme_minimal() +
    ggtitle("Empirical CDF", variable)
}

#Function which takes two dataframes and the desired variable name to graph a pdf of them.
#Call Example: "plot2pdf(barbieData, kenData, "Mean.Intensity")
plot2Pdf <- function(bardf2, kendf1, variable){
  ggplot() +
    geom_density(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    geom_density(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    
    theme_minimal() +
    ggtitle("PDF of ", variable)
}

#Function which takes two dataframes and the desired variable name to graph a pdf of them.
#Call Example: "plot2pdf(barbieData, kenData, "Mean.Intensity")
plot2Pdf <- function(df1, df2, variable){
  ggplot() +
    geom_density(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    geom_density(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    
    theme_minimal() +
    ggtitle("PDF of ", variable)
}
```

```{r}
plot2Ecdf(Filt6_KenMelanoma_Dataframe, Filt6_BarbieMelanoma_Dataframe, "Dry.Mass")
plot2Pdf(Filt6_KenMelanoma_Dataframe, Filt6_BarbieMelanoma_Dataframe, "Dry.Mass")
```

## Rescaling so that middle is 0,0

-   bottom left corner is (-500,-500)

-   top left corner is (-500,500)

-   top right corner is (500,500)

-   bottom left corner is (500, -500)

-   Maximum distance from center is 707.1

```{r}
#Function which aggregates data using the Tracking ID as the shared key.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
rescalePosition <- function(Df){
    Df$Centered_Position.X = Df$Position.X - 500
    Df$Centered_Position.Y = Df$Position.Y - 500
    Df$Distance_From_Center = sqrt(Df$Centered_Position.X^2 + Df$Centered_Position.Y^2)
    
    # Initialize left column
    Df$left <- 0
    
    # Find last row appearance of each unique Tracking.ID and mark as 1
    unique_ids <- unique(Df$Tracking.ID)
    for (id in unique_ids) {
        last_row_index <- max(which(Df$Tracking.ID == id))
        Df$left[last_row_index] <- 1
    }
    
    return(Df)
}

```




## LOGISTICAL REGRESSSION
```{r}
distanceFromCenterDf = rescalePosition(Filt6_BarbieMelanoma_Dataframe)

```

```{r}
# Assuming your dataframe is named 'data'
# Get 10 random row indices
training_indices <- sample(nrow(distanceFromCenterDf), 10000)

# Select rows based on random indices
training_rows <- distanceFromCenterDf[random_indices, ]
```

```{r}
# Assuming your dataframe is named 'data'
# Get 10 random row indices
testing_indices <- sample(nrow(distanceFromCenterDf), 1000)

# Select rows based on random indices
testing_rows <- distanceFromCenterDf[random_indices, ]
```
```{r}
model <- glm(left ~ Distance_From_Center, data = training_rows, family = binomial)
```

```{r}
probabilities = (predict(model, testing_rows, type = "response"))
```

```{r}
plot(testing_rows$Distance_From_Center, probabilities)
```





```{r}
# Assuming scaledDf is your original dataframe
# Columns to be included in the new dataframe
selected_columns <- c("Tracking.ID","Position.X", "Position.Y", "Centered_Position.X", "Centered_Position.Y", "Distance_From_Center", "left")

# Creating a new dataframe by selecting specific columns from scaledDf
new_df <- rescaledDf[selected_columns]

# Displaying the new dataframe
print(new_df)
```

```{r}
library(dplyr)

# Define the interval width
interval_width <- 25

# Create intervals for Distance_From_Center
rescaledDf$interval <- cut(rescaledDf$Distance_From_Center, breaks = seq(0, max(rescaledDf$Distance_From_Center) + interval_width, by = interval_width), include.lowest = TRUE, right = FALSE)

# Aggregate the dataframe and count the occurrences of left = 1 and left = 0 within each interval
aggregated_df <- rescaledDf %>%
  group_by(interval) %>%
  summarise(amount_left_0 = sum(left == 0),
            amount_left_1 = sum(left == 1))

# Display the aggregated dataframe

```

```         
```
