---
title: "FilteringCells"
author: "Tony Zhang"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(ggplot2)
library(RColorBrewer)
library(dplyr)

```

```{r}
Filt6_BarbieMelanoma_Dataframe = read.csv("Data/barbie6hrs.csv")
Filt6_KenMelanoma_Dataframe = read.csv("Data/ken6hrs.csv")
```

# Looking at individual cells

```{r}
singleCell_dataFrame = subset(Filt6_BarbieMelanoma_Dataframe, Tracking.ID == 2382)
```

```{r}
# Create the ggplot object with a darker background
p <- ggplot(singleCell_dataFrame, aes(x = Position.X, y = Position.Y, color = Frame)) +
  geom_point() +
  scale_color_gradientn(colours = terrain.colors(20)) +
  theme(panel.background = element_rect(fill = "black"))  # Remove panel border

# Print the plot
print(p)

```

```{r}
# Assuming 'singleCell_dataFrame' contains your data
# 'Frame' is the variable indicating the frame

# Define colors for the gradient
start_color <- "red"
end_color <- "blue"

# Create a color gradient based on the 'Frame' variable
color_gradient <- colorRampPalette(c(start_color, end_color))(nrow(singleCell_dataFrame))


# Plot the points without plotting lines initially
plot(singleCell_dataFrame$Position.X, singleCell_dataFrame$Position.Y, type = "n", xlab = "Position X", ylab = "Position Y")

# Draw lines between consecutive points with the same 'Frame' value
for (i in 2:nrow(singleCell_dataFrame)) {
  if (singleCell_dataFrame$Frame[i] - singleCell_dataFrame$Frame[i - 1] == 1) {
    lines(x = c(singleCell_dataFrame$Position.X[i - 1], singleCell_dataFrame$Position.X[i]), 
          y = c(singleCell_dataFrame$Position.Y[i - 1], singleCell_dataFrame$Position.Y[i]), 
          col = color_gradient[i])
  }
}

# Add points on top to ensure they are visible
points(singleCell_dataFrame$Position.X, singleCell_dataFrame$Position.Y, col = color_gradient)

```

# Filtering Based off Position

```{r}

# Haven't tested yet


## Function which completely removes all row occurences of a tracking ID whos final position was less than some distance from the edge. The edge is 1000 and 0 in both directions.
filter_DistanceFromEdge <- function(df, distance){

  filtered_df <- df %>%
    group_by(Tracking.ID) %>%
    filter((1000 - last(Position.X)) > distance & last(Position.X) > distance & (1000 - last(Position.Y)) > distance & last(Position.Y) > distance) %>%
  ungroup()
  result <- filtered_df
}
  
```

## Aggregating Data

```{r}
#Function which aggregates data using the Tracking ID as the shared key.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
aggregate_TrackingID <- function(nonAggDf){
  agg_df <- nonAggDf %>%
  group_by(Tracking.ID) %>%
  summarise(
    #Time between frame is 15 minutes
    Duration.minutes = (max(Frame) - min(Frame))*15,
    Duration.hours = Duration.minutes/60
  )
}


#Function which aggregates data using the Tracking ID as the shared key and creates a new column `maybeLeft` where if the final position was within some distance from the edge will be true.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
aggregate_TrackingID_EndPos <- function(nonAggDf, distance){

  agg_df <- nonAggDf %>%
    group_by(Tracking.ID) %>%
    summarise(
      #Time between frame is 15 minutes
      Duration.minutes = (max(Frame) - min(Frame))*15,
      Duration.hours = Duration.minutes/60,
      Position.FinalX = last(Position.X),
      Position.FinalY = last(Position.Y),
    #If distance from edge is more than `distance` it probably didn't leave

            maybeLeft = ifelse((1000 - Position.FinalX) > distance & Position.FinalX > distance & (1000 - Position.FinalY) > distance & last(Position.FinalY) > distance, FALSE, TRUE)

      )

}
```

```{r}
agg_Filt6_BarMel_Df = aggregate_TrackingID_EndPos(Filt6_BarbieMelanoma_Dataframe, 100)
head(agg_Filt6_BarMel_Df,20)


```

# Looking at filtered data

```{r}
#Function which takes two dataframes and the desired variable name to graph an empirical cdf of them.
#Call Example: "plot2Ecdf(barbieData, kenData, "Mean.Intensity")
plot2Ecdf <- function(bardf2, kendf1, variable){
  ggplot() +
    stat_ecdf(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    stat_ecdf(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    theme_minimal() +
    ggtitle("Empirical CDF", variable)
}

#Function which takes two dataframes and the desired variable name to graph a pdf of them.
#Call Example: "plot2pdf(barbieData, kenData, "Mean.Intensity")
plot2Pdf <- function(bardf2, kendf1, variable){
  ggplot() +
    geom_density(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    geom_density(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    
    theme_minimal() +
    ggtitle("PDF of ", variable)
}

#Function which takes two dataframes and the desired variable name to graph a pdf of them.
#Call Example: "plot2pdf(barbieData, kenData, "Mean.Intensity")
plot2Pdf <- function(df1, df2, variable){
  ggplot() +
    geom_density(data = kendf1, aes(x = !!rlang::sym(variable), color = "Ken Melanoma"), size = 1) +
    geom_density(data = bardf2, aes(x = !!rlang::sym(variable), color = "Barbie Melanoma"), size = 1) +
    labs(x = variable) +
    scale_color_manual(name = "Groups", values = c("Ken Melanoma" = "lightblue", "Barbie Melanoma" = "pink")) +
    
    theme_minimal() +
    ggtitle("PDF of ", variable)
}
```

```{r}
plot2Ecdf(Filt6_KenMelanoma_Dataframe, Filt6_BarbieMelanoma_Dataframe, "Dry.Mass")
plot2Pdf(Filt6_KenMelanoma_Dataframe, Filt6_BarbieMelanoma_Dataframe, "Dry.Mass")
```

## Rescaling so that middle is 0,0

-   bottom left corner is (-500,-500)

-   top left corner is (-500,500)

-   top right corner is (500,500)

-   bottom left corner is (500, -500)

-   Maximum distance from center is 707.1

```{r}
#Function which aggregates data using the Tracking ID as the shared key.
#Call Example: aggregatedData = aggregate_TrackingID(nonAggregatedData)
rescalePosition <- function(Df){
    Df$Centered_Position.X = Df$Position.X - 500
    Df$Centered_Position.Y = Df$Position.Y - 500
    Df$Distance_From_Edge = pmin(500 - abs(Df$Centered_Position.X), 500 - abs(Df$Centered_Position.Y))
    Df$Distance_From_Center = sqrt(Df$Centered_Position.X^2 + Df$Centered_Position.Y^2)
    
    # Initialize left column
    Df$left <- 0
    
    # Find last row appearance of each unique Tracking.ID and mark as 1
    unique_ids <- unique(Df$Tracking.ID)
    for (id in unique_ids) {
        last_row_index <- max(which(Df$Tracking.ID == id))
        Df$left[last_row_index] <- 1
    }
    
     # Initialize duration column
    Df$duration <- NA
    
    # Create duration column based on occurrence of Tracking.ID
    for (id in unique(Df$Tracking.ID)) {
        currDuration = 15
        for(index in which(Df$Tracking.ID == id)){
            Df$duration[index] = currDuration/60
            currDuration = currDuration+15
        }
    }
    
    
    return(Df)
}

```

```{r}
  curr = 5
for(i in 1:10){

  print(curr)
  curr = curr+5
}
```

## LOGISTICAL REGRESSSION

```{r}
distanceFromCenterDf = rescalePosition(Filt6_BarbieMelanoma_Dataframe)
```

```{r}
ggplot(distanceFromCenterDf, aes(x=Distance_From_Center, y=left)) + geom_point() +
      stat_smooth(method="glm", color="green", se=FALSE, 
                method.args = list(family=binomial))
```

```{r}
ggplot(distanceFromCenterDf, aes(x=Dry.Mass, y=left)) + geom_point() +
      stat_smooth(method="glm", color="green", se=FALSE, 
                method.args = list(family=binomial))
```

```{r}
ggplot(distanceFromCenterDf, aes(x=duration, y=left)) + geom_point() +
      stat_smooth(method="glm", color="green", se=FALSE, 
                method.args = list(family=binomial))
```

## LOGISTICAL REGRESSSION

```{r}
model <- glm(left ~ Distance_From_Center, data = distanceFromCenterDf, family = binomial)
```

```{r}
summary(model)
```

```{r}
model1 <- glm(left ~ Dry.Mass, data = distanceFromCenterDf, family = binomial)
summary(model1)
```

```{r}
model2 <- glm(left ~ duration+Dry.Mass+Distance_From_Center, data = distanceFromCenterDf, family = binomial )
summary(model2)
```

```{r}
subset = Dry.Mass<mean(Distance_From_Center)
```

```{r}
testing_indices <- sample(nrow(distanceFromCenterDf), 100)
testing_rows <- distanceFromCenterDf[testing_indices, ]
probabilities = (predict(model, testing_rows, type = "response"))
```

```{r}
# Assuming scaledDf is your original dataframe
# Columns to be included in the new dataframe
selected_columns <- c("Tracking.ID","Position.X", "Position.Y", "Centered_Position.X", "Centered_Position.Y", "Distance_From_Center", "left")

# Creating a new dataframe by selecting specific columns from scaledDf
new_df <- rescaledDf[selected_columns]

# Displaying the new dataframe
print(new_df)
```

```{r}

aggregated_df <- rescaledDf %>%
  group_by(interval) %>%
  summarise(amount_left_0 = sum(left == 0),
            amount_left_1 = sum(left == 1))
```

## Finding number of cells within some distance of eachother

```{r}

getNumberOfCellsWithin <- function(Df, distance){
  frameDf = subset(Df, Frame == 1)
  # Assuming scaledDf is your original dataframe
  # Columns to be included in the new dataframe
  selected_columns <- c("Position.X", "Position.Y")
  # Creating a new dataframe by selecting specific columns from scaledDf
  frame_df_positions <- frameDf[selected_columns]

  distancesMatrix = matrix(dist(frame_df_positions, method = "euclidean", diag = TRUE, upper = TRUE))

  for(col in 1:ncol(distancesMatrix)) {
    for(row in 1:nrow(distancesMatrix)) {
        print(distancesMatrix[row, col])
    }
  }
}



```

```{r}

# R program to illustrate how to calculate
# euclidean distance using dist() function
 
# Initializing a vector
vect1 <- c(1, 4)
 
# Initializing another vector
vect2 <- c(9, 4)
 
# Initializing another vector
vect3 <- c(1, 7)
 
# Initializing another vector
vect4 <- c(2, 1)
 
# Initializing another vector
vect5 <- c(1, 4)
 
# Initializing another vector
vect6 <- c(3, 7)
 
#Row bind vectors into a single matrix
twoDimensionalVect <- rbind(vect1, vect2, vect3,
                            vect4, vect5, vect6)
 
print("Euclidean distance between each pair of vectors is: ")
cat("\n\n")
 
# Calculate Euclidean distance between vectors using 
# built in dist method By passing two-dimensional 
# vector as a parameter Since we want to calculate
# Euclidean distance between each unique pair of vectors
# That is why we are passing Euclidean as a method
dist(twoDimensionalVect, method = "euclidean", diag = TRUE, upper = TRUE)
```

## Prof Adler stuff

```{r}
abline(lm(Dry.Mass ~Distance_From_Center,distanceFromCenterDf),col=2,lwd=3)
with(distanceFromCenterDf,lines(supsmu(Distance_From_Center,Dry.Mass),col=3,lwd=3))
```

## Looking at properties at difference distance intervals

```{r}

addDistanceIntervals <- function(Df, interval_width){
  Df$distance_interval <- cut(Df$Distance_From_Edge, breaks = seq(0, max(Df$Distance_From_Edge) + interval_width, by = interval_width), include.lowest = TRUE, right = FALSE)
  return (Df)
}

```

```{r}
interval25Df = addDistanceIntervals(distanceFromCenterDf,25)
```


```{r}
# Calculate mean for each interval
mean_by_interval <- aggregate(duration ~ distance_interval, data = interval25Df, FUN = mean)

#Reverse order of rows
mean_by_interval$distance_interval <- factor(mean_by_interval$distance_interval, levels = rev(levels(mean_by_interval$distance_interval)))

ggplot(mean_by_interval, aes(x = distance_interval, y = duration, group = 1)) +
  geom_line(linewidth = 1, color = "skyblue")+
  geom_point(size = 2, color = "blue") +
  labs(x = "Interval", y = "Mean Duration", title = "Mean Duration for Each Interval") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
ggplot(interval50Df, aes(x = distance_interval, y = duration)) +
  geom_boxplot() +
  labs(x = "Distance Interval", y = "Duration", title = "Boxplot of Duration for Each Interval")
```

```{r}
ggplot(interval50Df, aes(x = distance_interval, y = Dry.Mass)) +
  geom_boxplot() +
  labs(x = "Distance Interval", y = "Duration", title = "Boxplot of Duration for Each Interval")
```

```{r}
# Calculate mean for each interval
mean_by_interval <- aggregate(Dry.Mass ~ distance_interval, data = interval25Df, FUN = mean)
mean_by_interval$distance_interval <- factor(mean_by_interval$distance_interval, levels = rev(levels(mean_by_interval$distance_interval)))

# Create bar plot using ggplot2
ggplot(mean_by_interval, aes(x = distance_interval, y = Dry.Mass, group = 1)) +
  geom_line(linewidth = 1, color = "skyblue") + 
  geom_point(size = 2, color = "blue") +
  labs(x = "Distance Interval", y = "Dry Mass", title = "Mean Mass for Each Interval") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

```{r}
interval5Df = addDistanceIntervals(distanceFromCenterDf,5)
```

```{r}
mean_by_interval <- aggregate(Dry.Mass ~ distance_interval, data = interval5Df, FUN = mean)
mean_by_interval$distance_interval <- factor(mean_by_interval$distance_interval, levels = rev(levels(mean_by_interval$distance_interval)))

filtered_data <- mean_by_interval[1:30, ]

# Create bar plot using ggplot2
ggplot(filtered_data, aes(x = distance_interval, y = Dry.Mass, group = 1)) +
  geom_line(linewidth = 1, color = "skyblue") +
  geom_point(size = 2, color = "blue") +
  labs(x = "Distance Interval", y = "Mean Dry Mass", title = "Mean Dry Mass for Each Interval") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
interval1Df = addDistanceIntervals(distanceFromCenterDf,1)
```

```{r}
mean_by_interval <- aggregate(Dry.Mass ~ distance_interval, data = interval1Df, FUN = mean)
mean_by_interval$distance_interval <- factor(mean_by_interval$distance_interval, levels = rev(levels(mean_by_interval$distance_interval)))

filtered_data <- mean_by_interval[1:25, ]

# Create bar plot using ggplot2
ggplot(filtered_data, aes(x = distance_interval, y = Dry.Mass, group = 1)) +
  geom_line(linewidth = 1, color = "skyblue") +
  geom_point(size = 2, color = "blue") +
  labs(x = "Distance Interval", y = "Mean Dry Mass", title = "Mean Dry Mass for Each Interval") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Calculate mean for each interval
mean_by_interval <- aggregate(left ~ distance_interval, data = interval25Df, FUN = mean)
mean_by_interval$distance_interval <- factor(mean_by_interval$distance_interval, levels = rev(levels(mean_by_interval$distance_interval)))

# Create bar plot using ggplot2
ggplot(mean_by_interval, aes(x = distance_interval, y = left, group = 1)) +
  geom_line(linewidth = 1, color = "skyblue") + 
  geom_point(size = 2, color = "blue") +
  labs(x = "Distance Interval", y = "Percentage Stop Being Tracked", title = "Percentage Of Cells that stopped being tracked for Each Interval") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```
