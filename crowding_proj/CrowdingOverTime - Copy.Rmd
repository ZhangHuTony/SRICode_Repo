```{r}
library(MASS)
library(ggplot2)
library(tidyverse)
raw_df = read.csv('Data/ken6hrs.csv')
```

```{r}
df = subset(raw_df, select = c(Frame,Tracking.ID,Integrated.Intensity,Dry.Mass,Position.X, Position.Y))
```

Adding Normalized Integrated.Intensity

```{r}
df$Normalized_Intensity = df$Integrated.Intensity/df$Dry.Mass
```

```{r}
df <- df %>%
  group_by(Tracking.ID) %>%
  mutate(Normalized_Intensity_Next_Change = lead(Normalized_Intensity) - Normalized_Intensity,
         Normalized_Intensity_Prev_Change = Normalized_Intensity - lag(Normalized_Intensity))
```

# Crowding Metric

```{r}
calculate_correction <- function(center, radius, rect) {
  x <- center[1]
  y <- center[2]
  min_x <- rect[1]
  max_x <- rect[2]
  min_y <- rect[3]
  max_y <- rect[4]

  circle_area <- pi * radius^2

  # Check if the circle is fully inside the rectangle
  if (x - radius >= min_x && x + radius <= max_x &&
      y - radius >= min_y && y + radius <= max_y) {
    return(circle_area)
  }

  # Estimate the overlap area (this is a simplified estimation)
  overlap_area <- circle_area
  if (x - radius < min_x) {
    overlap_area <- overlap_area - pi * (radius - (x - min_x))^2 / 4
  }
  if (x + radius > max_x) {
    overlap_area <- overlap_area - pi * (radius - (max_x - x))^2 / 4
  }
  if (y - radius < min_y) {
    overlap_area <- overlap_area - pi * (radius - (y - min_y))^2 / 4
  }
  if (y + radius > max_y) {
    overlap_area <- overlap_area - pi * (radius - (max_y - y))^2 / 4
  }

  return(overlap_area)
}
```

```{r}
gaussian <- function(distance, sigma){
  exp(-(distance^2)/(2*(sigma^2)))
}
```

```{r}
calculate_crowding <- function(df, sigmas, window_width = 1000, new_column_names) {
  if (length(new_column_names) != length(sigmas)) {
    stop("Length of 'new_column_names' must match length of 'sigmas'")
  }
  
  for (i in seq_along(sigmas)) {
    sigma <- sigmas[i]
    new_column_name <- new_column_names[i]
    
    df <- df %>%
      group_by(Frame) %>%
      mutate(!!new_column_name := sapply(1:n(), function(i) {
        center <- c(Position.X[i], Position.Y[i])
        radius <- sigma  # Example: Adjust based on sigma
        rect <- c(0, window_width, 0, window_width)  # Assuming rectangular frame
      
        correction_factor <- (pi*radius^2)/calculate_correction(center, radius, rect)
      
        distances <- sqrt((Position.X - Position.X[i])^2 + (Position.Y - Position.Y[i])^2)
        (sum(gaussian(distances, sigma = sigma))-1) * correction_factor
    }))
  }
  
  return(df)
}
```

```{r}
sigmas = c(50,100,150,200,250)
crowding_cols = c("Crowding_50", "Crowding_100", "Crowding_150", "Crowding_200", "Crowding_250")
df = calculate_crowding(df,sigmas, new_column_names = crowding_cols)
```

# Data Visualization:

Making dfs that drop the NAs for next and previous intensity changes:

```{r}
df_next_clean <- df%>%
  drop_na(Normalized_Intensity_Next_Change)
```

## Methods

Create simple scatterplots with supsmu line of best fit through

```{r}
create_smoothed_plot <- function(x_col_name, y_col_name,df) {
  # Apply the supsmu function
  smooth_data <- supsmu(df[[x_col_name]], df[[y_col_name]])
  
  # Create the plot
  plot <- ggplot(df, aes_string(x = x_col_name, y = y_col_name)) +
    geom_point() +  # Scatter plot
    geom_line(aes(x = smooth_data$x, y = smooth_data$y), color = "blue") +  # Smoothed line
    labs(
      title = paste("Scatter Plot with Smoothed Line using supsmu for", x_col_name),
      x = paste(x_col_name),
      y = paste(y_col_name)
    )
  
  # Print the plot
  print(plot)
}
```

Create a new dataframe which holds the p-values and coefficients of linear models for many x columns over different Frame intervals.

```{r}
lm_analyze_intervals <- function(df, x_cols, y_col, interval_size = 30) {
  # Determine the range of the Frame column
  frame_min <- min(df$Frame)
  frame_max <- max(df$Frame)
  
  # Define the intervals
  intervals <- seq(frame_min, frame_max + interval_size, by = interval_size)
  
  p_values <- c()
  x_coefficients <- c()
  interval_labels <- c()
  crowding_cols <- c()
  
  for (i in 1:(length(intervals) - 1)) {
    interval_start <- intervals[i]
    interval_end <- intervals[i + 1]
    
    # Subset the data for the current interval
    df_subset <- df[df$Frame >= interval_start & df$Frame < interval_end, ]
    
    for (x_col in x_cols) {
      fit <- lm(df_subset[[y_col]] ~ df_subset[[x_col]])
      fit_info <- summary(fit)$coefficients
      x_coefficients <- append(x_coefficients, fit_info[2, 1])  # Coefficient
      p_values <- append(p_values, fit_info[2, 4])  # p-value
      interval_labels <- append(interval_labels, paste(interval_start, interval_end, sep = "-"))
      crowding_cols <- append(crowding_cols, x_col)
    }
  }
  
  # Create the results data frame
  linear_model_df <- data.frame(interval_labels, crowding_cols, x_coefficients, p_values)
  
  return(linear_model_df)
}
```

Plot the linear model results for each frame interval. Where x is the frame interval, y is the coefficient and the shape is dependent on the p-value

```{r}
plot_lm_interval_results <- function(linear_model_df) {
  # Convert interval_labels to a factor with the specified order
  interval_order <- unique(linear_model_df$interval_labels) 
  linear_model_df$interval_labels <- factor(linear_model_df$interval_labels, levels = interval_order)
  
  # Create a new column for shape categories
  linear_model_df$shape_category <- cut(linear_model_df$p_values,
                                        breaks = c(-Inf, 0.001, 0.05, Inf),
                                        labels = c("p<0.001", "0.001<p<0.05", "p>0.05"))
  
  # Create the scatter plot with shape mapped to the shape categories
  scatter_plot <- ggplot(linear_model_df, aes(x = interval_labels, y = x_coefficients, color = crowding_cols, shape = shape_category)) +
    geom_point(size = 3) +  # You can adjust the size of the points if needed
    labs(x = "Frame Intervals", y = "Coefficients", color = "Crowding Columns", shape = "P-Value Category") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels if needed
    theme_minimal() +
    scale_shape_manual(values = c("p<0.001" = 16, "0.001<p<0.05" = 8, "p>0.05" = 4))  # Adjust the shapes as needed
  
  # Print the scatter plot
  print(scatter_plot)
}
```

## Unweighted Crowding

### Normalized Intensity

See impact of "crowding" on intensity of cells.

```{r}
# Loop through each x column and create the plot
for (x_col in crowding_cols) {
  create_smoothed_plot(x_col, "Normalized_Intensity",df)
}
```

```{r}
p_values = c()
x_coefficients = c()
r_squares = c()

for(x_col in crowding_cols){
  fit = lm(df$Normalized_Intensity ~ df[[x_col]])
  fit_info = (summary(fit)$coefficients)
  x_coefficients <- append(x_coefficients, fit_info[2])
  p_values <- append(p_values, fit_info[8])
  r_squares <- append(r_squares, summary(fit)$r.squared)
}

int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
```

```{r}
linear_model_df = lm_analyze_intervals(df, crowding_cols, "Normalized_Intensity")

plot_lm_interval_results(linear_model_df)
```

### Change in Normalized Intensity 

Are cells next change in intensity influenced by how "crowded" the cell is?

```{r}
for (x_col in crowding_cols) {
  create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_next_clean)
}
```

```{r}
p_values = c()
x_coefficients = c()
r_squares = c()

for(x_col in crowding_cols){
  fit = lm(df$Normalized_Intensity_Next_Change ~ df[[x_col]])
  fit_info = (summary(fit)$coefficients)
  x_coefficients <- append(x_coefficients, fit_info[2])
  p_values <- append(p_values, fit_info[8])
  r_squares <- append(r_squares, summary(fit)$r.squared)
}

int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
```

```{r}
Int_Change_lmi_df = lm_analyze_intervals(df_next_clean, crowding_cols, "Normalized_Intensity_Next_Change")

plot_lm_interval_results(Int_Change_lmi_df)
```

## Intensity Weighted Crowding

```{r}
df <- df %>%
  mutate(across(all_of(crowding_cols), ~ . * Normalized_Intensity, .names = "{col}_Weighted"))

df_next_clean <- df%>%
  drop_na(Normalized_Intensity_Next_Change)
```

### Normalized Intensity
```{r}
weighted_crowding_cols <- c("Crowding_50_Weighted", "Crowding_100_Weighted", "Crowding_150_Weighted", "Crowding_200_Weighted", "Crowding_250_Weighted")

# Loop through each x column and create the plot
for (x_col in weighted_crowding_cols) {
  create_smoothed_plot(x_col, "Normalized_Intensity", df)
}
```
```{r}
p_values = c()
x_coefficients = c()
r_squares = c()

for(x_col in weighted_crowding_cols){
  fit = lm(df$Normalized_Intensity ~ df[[x_col]])
  fit_info = (summary(fit)$coefficients)
  x_coefficients <- append(x_coefficients, fit_info[2])
  p_values <- append(p_values, fit_info[8])
  r_squares <- append(r_squares, summary(fit)$r.squared)
}

int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
```

```{r}
weighted_lm_df = lm_analyze_intervals(df, weighted_crowding_cols, "Normalized_Intensity")

plot_lm_interval_results(weighted_lm_df)
```

### Change in Normalized Intensity

```{r}
for (x_col in weighted_crowding_cols) {
  create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_next_clean)
}
```
```{r}
p_values = c()
x_coefficients = c()
r_squares = c()

for(x_col in weighted_crowding_cols){
  fit = lm(df_next_clean$Normalized_Intensity_Next_Change ~ df_next_clean[[x_col]])
  fit_info = (summary(fit)$coefficients)
  x_coefficients <- append(x_coefficients, fit_info[2])
  p_values <- append(p_values, fit_info[8])
  r_squares <- append(r_squares, summary(fit)$r.squared)
}

int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
```

```{r}
weighted_change_lm_df = lm_analyze_intervals(df_next_clean, weighted_crowding_cols, "Normalized_Intensity_Next_Change")

plot_lm_interval_results(weighted_change_lm_df)
```

## Intensity Change Weighted Crowding

```{r}
df_clean = na.omit(df)

df_clean <- df_clean %>%
  mutate(across(all_of(crowding_cols), ~ . * Normalized_Intensity_Prev_Change, .names = "{col}_Change_Weighted"))

```

```{r}
change_weighted_crowding_cols <- c("Crowding_50_Change_Weighted", "Crowding_100_Change_Weighted", "Crowding_150_Change_Weighted", "Crowding_200_Change_Weighted", "Crowding_250_Change_Weighted")

for (x_col in change_weighted_crowding_cols) {
  create_smoothed_plot(x_col, "Normalized_Intensity_Next_Change", df_clean)
}
```
```{r}
p_values = c()
x_coefficients = c()
r_squares = c()

for(x_col in change_weighted_crowding_cols){
  fit = lm(df_clean$Normalized_Intensity_Next_Change ~ df_clean[[x_col]])
  fit_info = (summary(fit)$coefficients)
  x_coefficients <- append(x_coefficients, fit_info[2])
  p_values <- append(p_values, fit_info[8])
  r_squares <- append(r_squares, summary(fit)$r.squared)
}

int_change_lm_df = data.frame(crowding_cols, x_coefficients, p_values, r_squares)
print(int_change_lm_df)
```

```{r}
weighted_lm_df = lm_analyze_intervals(df_clean, change_weighted_crowding_cols, "Normalized_Intensity_Next_Change")

plot_lm_interval_results(weighted_lm_df)
```
